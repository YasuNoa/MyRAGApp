{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/gemini.ts"],"sourcesContent":["// Googleの生成AI（Gemini）を利用するためのライブラリをインポートします。\nimport { GoogleGenerativeAI } from \"@google/generative-ai\";\n// 環境変数を読み込むためのライブラリです。\nimport dotenv from \"dotenv\";\n\n// .envファイルの設定を読み込みます。\ndotenv.config();\n\n// 環境変数からGoogleのAPIキーを取得します。\nconst apiKey = process.env.GOOGLE_API_KEY;\nif (!apiKey) {\n    console.warn(\"GOOGLE_API_KEY is not set in .env file\");\n}\n\n// Geminiのクライアントを初期化します。\n// これを使って、Geminiのモデル（AI）にアクセスします。\nconst genAI = new GoogleGenerativeAI(apiKey || \"\");\n\n// テキストを「ベクトル（数値の配列）」に変換する関数です。\n// なぜこれが必要か？:\n// コンピュータやデータベース（Pinecone）は「言葉の意味」を直接比較することができません。\n// そこで、AIを使って言葉を数値化（ベクトル化）することで、\n// 「意味が似ている文章」を数学的に計算（距離計算）できるようにします。\n// これが「DBにデータが溜まる仕組み」の入り口であり、検索の要となります。\nexport async function getEmbedding(text: string): Promise<number[]> {\n    // \"text-embedding-004\" という、ベクトル化専用のモデルを使います。\n    const model = genAI.getGenerativeModel({ model: \"text-embedding-004\" });\n\n    // テキストを渡して、ベクトルデータを取得します。\n    const result = await model.embedContent(text);\n\n    // 結果の中から、数値の配列（values）だけを取り出して返します。\n    return result.embedding.values;\n}\n\n// ユーザーの意図を分類する関数\nexport async function classifyIntent(text: string): Promise<\"STORE\" | \"SEARCH\"> {\n    const model = genAI.getGenerativeModel({ model: \"gemini-pro\" });\n\n    const prompt = `\n    あなたはユーザーの意図を分類するAIです。\n    以下のテキストが「知識として覚えるべき情報」なのか、「何かを尋ねている質問」なのかを判断してください。\n    \n    テキスト: \"${text}\"\n    \n    出力は以下のいずれかのみを返してください。余計な文字は一切含めないでください。\n    - STORE (情報の入力、知識の追加、宣言文など)\n    - SEARCH (質問、検索、挨拶、会話など)\n    `;\n\n    const result = await model.generateContent(prompt);\n    const response = result.response;\n    const intent = response.text().trim().toUpperCase();\n\n    if (intent.includes(\"STORE\")) return \"STORE\";\n    return \"SEARCH\";\n}\n\n// ユーザーの質問と、検索で見つかった情報（コンテキスト）を元に、回答を生成する関数です。\n// なぜこれが必要か？:\n// AI（Gemini）は、あなたがPineconeに保存したデータのことを知りません。\n// そこで、Pineconeから検索した「関連情報（コンテキスト）」をヒントとしてプロンプトに含めることで、\n// AIがその情報を「拾って」回答できるようにします。これが RAG の仕組みです。\nexport async function generateAnswer(query: string, context: string[]): Promise<string> {\n    // \"gemini-flash-latest\" という、高速で安価なモデルを使います。\n    // 用途に応じて \"gemini-pro\" などに変更することも可能です。\n    const model = genAI.getGenerativeModel({ model: \"gemini-flash-latest\" });\n\n    // AIへの命令文（プロンプト）を作成します。\n    // ここで「コンテキスト」と「質問」をセットで渡すのがポイントです。\n    const prompt = `\n  あなたは親切なアシスタントです。以下のコンテキストを使用して、ユーザーの質問に答えてください。\n  答えがコンテキストにない場合は、「提供された情報からはわかりません」と答えてください。\n  \n  コンテキスト:\n  ${context.join(\"\\n\\n\")}\n  \n  質問:\n  ${query}\n  `;\n\n    // プロンプトをAIに送信し、回答を生成させます。\n    const result = await model.generateContent(prompt);\n\n    // 生成されたテキストを返します。\n    return result.response.text();\n}\n"],"names":[],"mappings":"AAAA,6CAA6C;;;;;;;;;AAC7C;AACA,uBAAuB;AACvB;;;AAEA,sBAAsB;AACtB,kJAAM,CAAC,MAAM;AAEb,4BAA4B;AAC5B,MAAM,SAAS,QAAQ,GAAG,CAAC,cAAc;AACzC,IAAI,CAAC,QAAQ;IACT,QAAQ,IAAI,CAAC;AACjB;AAEA,wBAAwB;AACxB,iCAAiC;AACjC,MAAM,QAAQ,IAAI,sLAAkB,CAAC,UAAU;AAQxC,eAAe,aAAa,IAAY;IAC3C,6CAA6C;IAC7C,MAAM,QAAQ,MAAM,kBAAkB,CAAC;QAAE,OAAO;IAAqB;IAErE,0BAA0B;IAC1B,MAAM,SAAS,MAAM,MAAM,YAAY,CAAC;IAExC,oCAAoC;IACpC,OAAO,OAAO,SAAS,CAAC,MAAM;AAClC;AAGO,eAAe,eAAe,IAAY;IAC7C,MAAM,QAAQ,MAAM,kBAAkB,CAAC;QAAE,OAAO;IAAa;IAE7D,MAAM,SAAS,CAAC;;;;WAIT,EAAE,KAAK;;;;;IAKd,CAAC;IAED,MAAM,SAAS,MAAM,MAAM,eAAe,CAAC;IAC3C,MAAM,WAAW,OAAO,QAAQ;IAChC,MAAM,SAAS,SAAS,IAAI,GAAG,IAAI,GAAG,WAAW;IAEjD,IAAI,OAAO,QAAQ,CAAC,UAAU,OAAO;IACrC,OAAO;AACX;AAOO,eAAe,eAAe,KAAa,EAAE,OAAiB;IACjE,4CAA4C;IAC5C,sCAAsC;IACtC,MAAM,QAAQ,MAAM,kBAAkB,CAAC;QAAE,OAAO;IAAsB;IAEtE,wBAAwB;IACxB,mCAAmC;IACnC,MAAM,SAAS,CAAC;;;;;EAKlB,EAAE,QAAQ,IAAI,CAAC,QAAQ;;;EAGvB,EAAE,MAAM;EACR,CAAC;IAEC,0BAA0B;IAC1B,MAAM,SAAS,MAAM,MAAM,eAAe,CAAC;IAE3C,kBAAkB;IAClB,OAAO,OAAO,QAAQ,CAAC,IAAI;AAC/B"}},
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/pinecone.ts"],"sourcesContent":["// Pineconeのクライアントライブラリをインポートします。\n// これを使うことで、PineconeのAPIを簡単に呼び出すことができます。\nimport { Pinecone } from \"@pinecone-database/pinecone\";\n// 環境変数（.envファイル）を読み込むためのライブラリです。\n// APIキーなどの機密情報はコードに直接書かず、環境変数として管理するのがセキュリティの基本です。\nimport dotenv from \"dotenv\";\n\n// .envファイルの内容を process.env に読み込みます。\ndotenv.config();\n\n// 環境変数からPineconeのAPIキーとインデックス名（DB名）を取得します。\nconst apiKey = process.env.PINECONE_API_KEY;\nconst indexName = process.env.PINECONE_INDEX;\n\n// もしAPIキーが設定されていなければ、警告を出します。\n// これがないと、接続エラーの原因がわからずデバッグに苦労するためです。\nif (!apiKey) {\n    console.warn(\"PINECONE_API_KEY is not set in .env file\");\n}\n\n// Pineconeのクライアントを初期化します。\n// ここでAPIキーを渡すことで、クラウド上のPineconeサービスと認証を行います。\n// これ以降、この `pc` オブジェクトを使ってデータベース操作を行います。\nconst pc = new Pinecone({\n    apiKey: apiKey || \"\",\n});\n\n// 使用するインデックス（データベース）を指定します。\n// インデックスは事前にPineconeの管理画面で作成しておく必要があります。\n// ここでは .env で指定された名前（なければ \"quickstart\"）のインデックスに接続します。\nconst index = pc.index(indexName || \"quickstart\");\n\n// ドキュメント（テキストとベクトル）を保存・更新する関数です。\n// id: ドキュメントの一意なID\n// text: 元のテキスト（検索結果として表示するため）\n// vector: テキストを数値化したベクトルデータ（検索のため）\nexport async function upsertDocument(id: string, text: string, vector: number[]) {\n    // index.upsert() を使ってデータを保存します。\n    // Pineconeには、ID、ベクトル(values)、メタデータ(metadata)をセットで保存できます。\n    await index.upsert([\n        {\n            id: id,\n            values: vector,\n            metadata: { text }, // 元のテキストも一緒に保存しておかないと、検索しても「どの文章か」がわかりません。\n        },\n    ]);\n}\n\n// 類似するドキュメントを検索する関数です。\n// vector: 検索クエリ（質問文）のベクトル\n// topK: 上位何件を取得するか（デフォルトは3件）\nexport async function queryDocuments(vector: number[], topK: number = 3): Promise<string[]> {\n    // index.query() を使って、渡されたベクトルに近いデータを検索します。\n    const queryResponse = await index.query({\n        vector: vector,\n        topK: topK,\n        includeMetadata: true, // メタデータ（元のテキスト）も含めて取得します。\n    });\n\n    // 検索結果から、元のテキストだけを取り出して配列として返します。\n    // match.metadata?.text が存在するものだけをフィルタリングしています。\n    return queryResponse.matches\n        .map((match) => match.metadata?.text as string)\n        .filter((text) => text !== undefined);\n}\n"],"names":[],"mappings":"AAAA,iCAAiC;AACjC,wCAAwC;;;;;;;AACxC;AACA,iCAAiC;AACjC,mDAAmD;AACnD;;;AAEA,oCAAoC;AACpC,kJAAM,CAAC,MAAM;AAEb,2CAA2C;AAC3C,MAAM,SAAS,QAAQ,GAAG,CAAC,gBAAgB;AAC3C,MAAM,YAAY,QAAQ,GAAG,CAAC,cAAc;AAE5C,8BAA8B;AAC9B,qCAAqC;AACrC,IAAI,CAAC,QAAQ;IACT,QAAQ,IAAI,CAAC;AACjB;AAEA,0BAA0B;AAC1B,6CAA6C;AAC7C,wCAAwC;AACxC,MAAM,KAAK,IAAI,iLAAQ,CAAC;IACpB,QAAQ,UAAU;AACtB;AAEA,4BAA4B;AAC5B,yCAAyC;AACzC,sDAAsD;AACtD,MAAM,QAAQ,GAAG,KAAK,CAAC,aAAa;AAM7B,eAAe,eAAe,EAAU,EAAE,IAAY,EAAE,MAAgB;IAC3E,gCAAgC;IAChC,yDAAyD;IACzD,MAAM,MAAM,MAAM,CAAC;QACf;YACI,IAAI;YACJ,QAAQ;YACR,UAAU;gBAAE;YAAK;QACrB;KACH;AACL;AAKO,eAAe,eAAe,MAAgB,EAAE,OAAe,CAAC;IACnE,2CAA2C;IAC3C,MAAM,gBAAgB,MAAM,MAAM,KAAK,CAAC;QACpC,QAAQ;QACR,MAAM;QACN,iBAAiB;IACrB;IAEA,kCAAkC;IAClC,+CAA+C;IAC/C,OAAO,cAAc,OAAO,CACvB,GAAG,CAAC,CAAC,QAAU,MAAM,QAAQ,EAAE,MAC/B,MAAM,CAAC,CAAC,OAAS,SAAS;AACnC"}},
    {"offset": {"line": 273, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/line.ts"],"sourcesContent":["import { Client, MiddlewareConfig } from \"@line/bot-sdk\";\nimport dotenv from \"dotenv\";\n\ndotenv.config();\n\nconst config: MiddlewareConfig = {\n    channelAccessToken: process.env.LINE_CHANNEL_ACCESS_TOKEN || \"\",\n    channelSecret: process.env.LINE_CHANNEL_SECRET || \"\",\n};\n\nexport const lineClient = new Client({\n    channelAccessToken: config.channelAccessToken || \"\",\n    channelSecret: config.channelSecret,\n});\nexport const lineConfig = config;\n\nexport async function replyMessage(replyToken: string, text: string) {\n    await lineClient.replyMessage(replyToken, {\n        type: \"text\",\n        text: text,\n    });\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEA,kJAAM,CAAC,MAAM;AAEb,MAAM,SAA2B;IAC7B,oBAAoB,QAAQ,GAAG,CAAC,yBAAyB,IAAI;IAC7D,eAAe,QAAQ,GAAG,CAAC,mBAAmB,IAAI;AACtD;AAEO,MAAM,aAAa,IAAI,uMAAM,CAAC;IACjC,oBAAoB,OAAO,kBAAkB,IAAI;IACjD,eAAe,OAAO,aAAa;AACvC;AACO,MAAM,aAAa;AAEnB,eAAe,aAAa,UAAkB,EAAE,IAAY;IAC/D,MAAM,WAAW,YAAY,CAAC,YAAY;QACtC,MAAM;QACN,MAAM;IACV;AACJ"}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"sources":["file:///app/auth.config.ts"],"sourcesContent":["import type { NextAuthConfig } from \"next-auth\";\n\nexport const authConfig = {\n    pages: {\n        signIn: \"/login\",\n    },\n    callbacks: {\n        async signIn({ account, profile }) {\n            if (account?.provider === \"line\") {\n                if (!profile?.email) {\n                    return \"/login?error=EmailRequired\";\n                }\n            }\n            return true;\n        },\n        authorized({ auth, request: { nextUrl } }) {\n            const isLoggedIn = !!auth?.user;\n            const isOnDashboard = nextUrl.pathname.startsWith(\"/\");\n            const isOnLogin = nextUrl.pathname.startsWith(\"/login\");\n            const isOnRegister = nextUrl.pathname.startsWith(\"/register\");\n\n            if (isOnDashboard) {\n                // ログイン画面と登録画面は誰でもアクセスOK\n                if (isOnLogin || isOnRegister) return true;\n                // その他のページはログイン必須\n                // if (isLoggedIn) return true;\n                // return false; // Redirect unauthenticated users to login page\n            }\n            return true;\n        },\n    },\n    providers: [], // Providers are configured in auth.ts\n} satisfies NextAuthConfig;\n"],"names":[],"mappings":";;;;AAEO,MAAM,aAAa;IACtB,OAAO;QACH,QAAQ;IACZ;IACA,WAAW;QACP,MAAM,QAAO,EAAE,OAAO,EAAE,OAAO,EAAE;YAC7B,IAAI,SAAS,aAAa,QAAQ;gBAC9B,IAAI,CAAC,SAAS,OAAO;oBACjB,OAAO;gBACX;YACJ;YACA,OAAO;QACX;QACA,YAAW,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,EAAE;YACrC,MAAM,aAAa,CAAC,CAAC,MAAM;YAC3B,MAAM,gBAAgB,QAAQ,QAAQ,CAAC,UAAU,CAAC;YAClD,MAAM,YAAY,QAAQ,QAAQ,CAAC,UAAU,CAAC;YAC9C,MAAM,eAAe,QAAQ,QAAQ,CAAC,UAAU,CAAC;YAEjD,IAAI,eAAe;gBACf,wBAAwB;gBACxB,IAAI,aAAa,cAAc,OAAO;YACtC,iBAAiB;YACjB,+BAA+B;YAC/B,gEAAgE;YACpE;YACA,OAAO;QACX;IACJ;IACA,WAAW,EAAE;AACjB"}},
    {"offset": {"line": 367, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = globalThis as unknown as { prisma: PrismaClient };\n\nexport const prisma = globalForPrisma.prisma || new PrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAEjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 380, "column": 0}, "map": {"version":3,"sources":["file:///app/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport Credentials from \"next-auth/providers/credentials\";\nimport { authConfig } from \"./auth.config\";\nimport { PrismaClient } from \"@prisma/client\";\nimport bcrypt from \"bcryptjs\";\n\nimport Line from \"next-auth/providers/line\";\n\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport { prisma } from \"./src/lib/prisma\";\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n    ...authConfig,\n    adapter: PrismaAdapter(prisma),\n    session: { strategy: \"jwt\" },\n    providers: [\n        Line({\n            clientId: process.env.AUTH_LINE_ID,\n            clientSecret: process.env.AUTH_LINE_SECRET,\n            authorization: { params: { scope: \"openid profile email\" } },\n            allowDangerousEmailAccountLinking: true,\n        }),\n        Credentials({\n            credentials: {\n                username: { label: \"Phone Number\", type: \"text\" },\n                password: { label: \"Password\", type: \"password\" },\n            },\n            authorize: async (credentials) => {\n                if (!credentials?.username || !credentials?.password) return null;\n\n                const user = await prisma.user.findUnique({\n                    where: { phoneNumber: credentials.username as string },\n                });\n\n                if (!user || !user.password) {\n                    return null;\n                }\n\n                const isValid = await bcrypt.compare(\n                    credentials.password as string,\n                    user.password\n                );\n\n                if (isValid) {\n                    return {\n                        id: user.id,\n                        name: user.name,\n                        email: user.email,\n                    };\n                }\n\n                return null;\n            },\n        }),\n    ],\n});\n\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;;;;;;;;AAEO,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,IAAA,kKAAQ,EAAC;IACxD,GAAG,8HAAU;IACb,SAAS,IAAA,uKAAa,EAAC,gIAAM;IAC7B,SAAS;QAAE,UAAU;IAAM;IAC3B,WAAW;QACP,IAAA,gKAAI,EAAC;YACD,UAAU,QAAQ,GAAG,CAAC,YAAY;YAClC,cAAc,QAAQ,GAAG,CAAC,gBAAgB;YAC1C,eAAe;gBAAE,QAAQ;oBAAE,OAAO;gBAAuB;YAAE;YAC3D,mCAAmC;QACvC;QACA,IAAA,uKAAW,EAAC;YACR,aAAa;gBACT,UAAU;oBAAE,OAAO;oBAAgB,MAAM;gBAAO;gBAChD,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YACpD;YACA,WAAW,OAAO;gBACd,IAAI,CAAC,aAAa,YAAY,CAAC,aAAa,UAAU,OAAO;gBAE7D,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBACtC,OAAO;wBAAE,aAAa,YAAY,QAAQ;oBAAW;gBACzD;gBAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;oBACzB,OAAO;gBACX;gBAEA,MAAM,UAAU,MAAM,8IAAM,CAAC,OAAO,CAChC,YAAY,QAAQ,EACpB,KAAK,QAAQ;gBAGjB,IAAI,SAAS;oBACT,OAAO;wBACH,IAAI,KAAK,EAAE;wBACX,MAAM,KAAK,IAAI;wBACf,OAAO,KAAK,KAAK;oBACrB;gBACJ;gBAEA,OAAO;YACX;QACJ;KACH;AACL"}},
    {"offset": {"line": 461, "column": 0}, "map": {"version":3,"sources":["file:///app/src/index.ts"],"sourcesContent":["// HonoのサーバーをNode.js環境で動かすためのアダプターをインポートします。\n// これがないと、Honoで作ったアプリを通常のNode.jsサーバーとして起動できません。\n// import { serve } from \"@hono/node-server\"; // src/server.ts に移動\n// Webフレームワーク「Hono」本体をインポートします。\n// Honoは軽量で高速なWebフレームワークで、APIサーバーを作るのに適しています。\nimport { Hono } from \"hono\";\n// Gemini（AI）を操作するための自作関数をインポートします。\n// getEmbedding: テキストをベクトル（数値の羅列）に変換する関数\n// generateAnswer: 検索結果を元にAIに回答を生成させる関数\nimport { getEmbedding, generateAnswer, classifyIntent } from \"./lib/gemini\";\n// Pinecone（ベクトルデータベース）を操作するための自作関数をインポートします。\n// upsertDocument: ベクトルデータを保存・更新する関数\n// queryDocuments: 類似するベクトルを検索する関数\nimport { upsertDocument, queryDocuments } from \"./lib/pinecone\";\n// LINE Bot関連の機能をインポートします。\n// lineConfig: LINEの設定情報\n// lineClient: LINE APIを叩くためのクライアント\n// replyMessage: ユーザーに返信を送るための関数\nimport { lineConfig, lineClient, replyMessage } from \"./lib/line\";\n// LINEからの署名検証などを行うためのミドルウェアですが、今回は手動実装しているため未使用の可能性があります。\nimport { middleware } from \"@line/bot-sdk\";\n// 一意なID（UUID）を生成するためのライブラリです。\n// データベースに保存する際、ドキュメントごとに重複しないIDを付けるために使います。\nimport { v4 as uuidv4 } from \"uuid\";\nimport { auth } from \"../auth\";\nimport { prisma } from \"./lib/prisma\";\n\n// Honoアプリのインスタンスを作成します。\n// これがサーバーの本体となり、ここにルート（URLごとの処理）を追加していきます。\nconst app = new Hono().basePath(\"/api\");\n\n// データを保存するAPIエンドポイントを定義します。\n// HTTPメソッドは「POST」を使います（データの作成・追加はPOSTが一般的だからです）。\n// URLは \"/add\" です。\n// なぜこれが必要か？: ユーザーがチャットボットに知識を追加できるようにするためです。\napp.post(\"/add\", async (c) => {\n    // リクエストボディからJSONデータを取得し、その中の \"text\" プロパティを取り出します。\n    // awaitが必要なのは、ネットワーク経由でデータを受け取る処理が非同期だからです。\n    const { text } = await c.req.json();\n\n    // もし text が空っぽだったら、エラーを返します。\n    // 400 は \"Bad Request\"（リクエストが不正）という意味のステータスコードです。\n    if (!text) return c.json({ error: \"Text is required\" }, 400);\n\n    try {\n        // 処理が始まったことをログに出力します（デバッグ用）。\n        console.log(`[保存中] テキスト: ${text}`);\n\n        // 1. テキストをベクトル化（数値化）します。\n        // AIは言葉を直接理解できないので、意味を表す数値のリストに変換する必要があります。\n        const vector = await getEmbedding(text);\n\n        // 2. Pinecone（データベース）に保存します。\n        // 保存には一意なIDが必要なので、uuidv4() でランダムなIDを生成します。\n        const id = uuidv4();\n        // ID、元のテキスト、そしてベクトルデータの3つをセットで保存します。\n        await upsertDocument(id, text, vector);\n\n        // 保存が成功したことをログに出力します。\n        console.log(`[完了] ID: ${id} で保存しました。`);\n\n        // クライアント（呼び出し元）に成功したことと、生成されたIDをJSONで返します。\n        return c.json({ success: true, id });\n    } catch (e) {\n        // もし途中でエラーが発生した場合（API制限やDB接続エラーなど）はここに来ます。\n        console.error(e);\n        // 500 は \"Internal Server Error\"（サーバー内部エラー）という意味です。\n        return c.json({ error: \"Failed to add document\" }, 500);\n    }\n});\n\n// 質問を受け付けて回答するAPIエンドポイントを定義します。\n// ここでもデータの送信を伴うので「POST」を使います。\n// URLは \"/ask\" です。\napp.post(\"/ask\", async (c) => {\n    const session = await auth();\n    if (!session || !session.user?.id) {\n        return c.json({ error: \"Unauthorized\" }, 401);\n    }\n    const userId = session.user.id;\n\n    const { query } = await c.req.json();\n    if (!query) return c.json({ error: \"Query is required\" }, 400);\n\n    try {\n        console.log(`[検索中] 質問: ${query}`);\n\n        // 1. ユーザーのメッセージをDBに保存\n        await prisma.message.create({\n            data: {\n                content: query,\n                role: \"user\",\n                userId: userId,\n            },\n        });\n\n        // 2. ベクトル化 & 検索\n        const vector = await getEmbedding(query);\n        const context = await queryDocuments(vector);\n\n        // 3. 回答生成\n        const answer = await generateAnswer(query, context);\n\n        // 4. AIの回答をDBに保存\n        await prisma.message.create({\n            data: {\n                content: answer,\n                role: \"assistant\",\n                userId: userId,\n            },\n        });\n\n        console.log(`[回答] ${answer}`);\n        return c.json({ answer, context });\n    } catch (e) {\n        console.error(e);\n        return c.json({ error: \"Failed to get answer\" }, 500);\n    }\n});\n\n// LINEからのWebhookを受け取るエンドポイントです。\n// LINE Botにメッセージが送られると、LINEのサーバーからこのURLに通知が来ます。\napp.post(\"/webhook/line\", async (c) => {\n    // LINEからのリクエストには、改ざん防止のための署名（signature）が付いています。\n    const signature = c.req.header(\"x-line-signature\");\n    // 署名がないリクエストは不正とみなしてエラーにします。\n    if (!signature) return c.json({ error: \"Signature missing\" }, 400);\n\n    // リクエストの本文（body）をテキストとして取得します。\n    const body = await c.req.text();\n\n    // 本来はここで署名の検証（verify）を行うべきですが、現在は実装されていません。\n    // 本番環境では @line/bot-sdk の middleware を使うか、手動で検証ロジックを書く必要があります。\n    // 現状は「署名があるか」のチェックのみで、中身の正当性はチェックしていないことに注意してください。\n\n    // LINEからのイベントデータ（メッセージ受信など）を取り出します。\n    const events = JSON.parse(body).events;\n\n    // 届いたイベントを1つずつ処理します\n    for (const event of events) {\n        if (event.type === \"message\" && event.message.type === \"text\") {\n            const userMessage = event.message.text;\n            const replyToken = event.replyToken;\n            const lineUserId = event.source.userId; // LINEのユーザーID\n\n            console.log(`[LINE] 受信: ${userMessage} (from ${lineUserId})`);\n\n            try {\n                // 1. LINE IDからアプリのユーザーIDを特定する\n                const account = await prisma.account.findFirst({\n                    where: {\n                        provider: \"line\",\n                        providerAccountId: lineUserId,\n                    },\n                });\n\n                // ユーザーが見つからない場合は、とりあえずログだけ出して処理続行（またはエラー返信）\n                // ここでは「ゲスト」として扱うか、エラーにするか迷いますが、一旦保存せずに進めます。\n                const userId = account?.userId;\n\n                // 2. ユーザーのメッセージをDBに保存（ユーザーが特定できた場合のみ）\n                if (userId) {\n                    await prisma.message.create({\n                        data: {\n                            content: userMessage,\n                            role: \"user\",\n                            userId: userId,\n                        },\n                    });\n                }\n\n                // 3. 意図分類 (STORE or SEARCH)\n                // ここでGeminiに「これは覚えさせるやつ？質問？」と聞きます\n                // import { classifyIntent } from \"./lib/gemini\"; を忘れずに！\n                const intent = await classifyIntent(userMessage);\n                console.log(`[LINE] 意図: ${intent}`);\n\n                let replyText = \"\";\n\n                if (intent === \"STORE\") {\n                    // === 覚えるモード ===\n                    const vector = await getEmbedding(userMessage);\n                    const id = uuidv4();\n                    await upsertDocument(id, userMessage, vector);\n                    replyText = \"覚えました！🧠\";\n                } else {\n                    // === 検索・会話モード ===\n                    const vector = await getEmbedding(userMessage);\n                    const context = await queryDocuments(vector);\n                    replyText = await generateAnswer(userMessage, context);\n                }\n\n                // 4. LINEに返信\n                await replyMessage(replyToken, replyText);\n                console.log(`[LINE] 返信: ${replyText}`);\n\n                // 5. AIの回答をDBに保存（ユーザーが特定できた場合のみ）\n                if (userId) {\n                    await prisma.message.create({\n                        data: {\n                            content: replyText,\n                            role: \"assistant\",\n                            userId: userId,\n                        },\n                    });\n                }\n\n            } catch (e) {\n                console.error(\"[LINE] Error:\", e);\n                await replyMessage(replyToken, \"すみません、エラーが発生しました。\");\n            }\n        }\n    }\n\n    return c.json({ success: true });\n});\n\n// サーバー起動処理は src/server.ts に移動しました。\n\n// アプリケーションをエクスポートします。\n// Vercelなどのホスティングサービスは、この default export を使ってアプリを起動します。\nexport default app;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 680, "column": 0}, "map": {"version":3,"sources":["file:///app/app/api/%5B%5B...route%5D%5D/route.ts"],"sourcesContent":["import { handle } from \"hono/vercel\";\nimport app from \"@/src/index\";\n\nexport const GET = handle(app);\nexport const POST = handle(app);\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;;;AAEO,MAAM,MAAM,IAAA,wKAAM,EAAC,yHAAG;AACtB,MAAM,OAAO,IAAA,wKAAM,EAAC,yHAAG"}}]
}